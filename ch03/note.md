### 内存模型

### 无抽象
直接使用物理地址作为进程地址, 多个进程跑的时候需要swap

### 使用base，limit寄存器
使用base, limit一对寄存器作为进程在物理内存里的范围，有某些场景比如进程需要动态allocate一些内存的不太好加

### 使用address space的内存回收
有两种方法可以用于记录内存使用
1. bitmap
使用一个1/0来代表一定量的bit的使用情况
2. 链表
每个entry记录process/hole, start, limit, 前后连接，其中process/hole信息占用1 bit，
也可做两个链表分别记录已用进程内存链表和空闲内存链表

将多个进程向一侧合并compact，这种操作比较耗时，最后可以留下一块完整的空闲内存
不进行合并操作的话，如何利用空闲的内存，分别有
1. first fit 利用第一个遇到的够用的空，第二次可以在这个节点后找不从左边再找一遍
2. best fit  利用最相近的空的内存
3. wrost fit 利用最大的空中的内存
4. quick fit 提前准备好一些大小的空内存等待需要内存的进程

### 虚拟内存
程序太大无法完全放进内存的时候，前面的方案都无法运行。
